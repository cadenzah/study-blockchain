```solidity

function withdrawCoins(){ // 취약점이 발생하는 지점!
  uint withdrawAmount = balances[msg.sender]; // 보유하고 있던 토큰 전액을 취한다
  Wallet wallet = Wallet(msg.sender); //  토큰을 환불해줄 지갑을 취한다
  wallet.payout.value(withdrawAmount)(); // 실제 토큰을 돌려주는 작업
  balances[msg.sender] = 0;
}

```

## 문제점

`Wallet` 객체가 당신의 컨트랙트와 어떻게 상호작용할지 정확히 알 수 없다. 즉, 예상과 다른 흐름으로 작동할 수도 있다는 것. 위 코드에서 문제가 되는 부분은 바로 이 부분이다:

```solidity
wallet.payout.value(withdrawAmount)();
```

이 코드에서는 `Fundraiser` 컨트랙트 상에서 외부 컨트랙트인 `Wallet` 컨트랙트 인스턴스의 메서드를 호출한다. 즉, 해당 라인 이후의 코드는 `wallet.payout()` 메서드의 실행이 완료되기 전까지는 실행되지 않는다.

만약, `wallet.payout()`이 다시 `Fundraiser`의 `.withdrawCoins()`를 호출한다면? `balances[msg.sender]`의 값을 0으로 설정하는 일은 벌어지지 못하고 무한 재귀가 발생할 것이다. DAO 내 각 사용자의 토큰 잔액은 그대로 유지된 상태에서, 토큰 송금이 계속해서 이루어지고, DAO의 토큰은 마침내 고갈되는 양상이다. 이것이 DAO Attack의 본질이다.

아주 간단한 코드이지만, 간과하기 쉬운 치명적인 오류임을 알 수 있다.
