> ## Boilerplate code
> https://github.com/udacity/FlightSurety

- Data 파일은 데이터만을 저장하는 컨트랙트
- App 파일은 기타 어플리케이션 로직이 모두 들어있는 컨트랙트
- 대부분의 코드가 빈칸이므로, 알아서 채우자
- 테스트 케이스를 잘 작성하자
  - `truffle test`를 하든, 직접 DApp을 통하여 하든

## App - `FlightSurveyData.sol`

- `pure` 키워드는 컴파일 에러를 피하기 위하여 적힌 것으로, 차후 메서드 코드를 변경한다면 적절하게 제거하자

### `.registerAirline`

- 항공사가 보험판매 DApp에 자신을 등록하는 메서드
  - 항공사가 4개 이상이면, 기존 항공사들의 투표를 통한 동의가 필요함

### `.buy`

- 사용자가 특정 항공편에 대한 보험을 구입하는 메서드

### `.creditInsurees`

- 환불을 직접 하는 것이 아니라, 외부로부터 요청이 들어왔을 때에 `.pay`를 실행하여 보내준다(이벤트 드리븐).

### `.fund`

- 항공사가 최종적으로 보험 DApp 가입시 지불해야 하는 가입비에 대한 지불 메서드

## Data - `FlightSurveyApp.sol`

- 어플리케이션 내에서 공통적인 프로토콜로서 사용될 *상태 코드* 상수를 여러 가지 설정
- 환불이 발생해야 하는 유일한 경우는 `STATUS_CODE_LATE_AIRLINE`에 의한 것
  - 그 외의 경우는 *항공사에 의하여 지연이 발생한 경우* 가 아니므로 보상 필요 없음
- App과 Data의 처리 로직에 집중할 수 있도록, 직전 강의에서 사용했던 Oracle 관련 코드들을 다 집어넣어놨다
  - 이미 존재하는 자료구조들은 Oracle에 대응하기 위한 것으로, 그 외에는 자유롭게 수정해도 된다
  - 오라클 관련 코드는 최하단에 위치 - 그대로 사용하면 된다

### `.registerAirline` / `.registerFlight`

- 사용자가 등록 가능한 항공편을 직접 컨트랙트 상에 하드코딩할 수도 있지만, 항공사로 하여금 항공편을 등록하고, 등록된 항공편들을 DApp 차원에서 마치 API처럼 제공할 수 있도록 기능을 만든다면 보다 발전된 버전의 UI를 제공할 수 있을 것

### `.processFlightStatus`

- 가장 핵심 코드
- 오라클로부터 항공편 데이터를 받은 뒤, 유저 단으로 돌려주기 위하여 데이터를 잘 포장하는 기능을 담당하는 메서드
  - 항공편이 제 시간에 도착하였고, STATUS_CODE가 20이 아니라면, 이에 대응하는 정상적인 다음 과정으로 사용자를 안내할 수 있어야 함
  - STATUS_CODE가 20인 경우에만 환불 관련한 로직을 처리하도록 작성하면 됨

### `.fetchFlightStatus`

- UI로부터 트리거되는 메서드
  - 클라이언트 DApp에서 버튼이 클릭되면, 그 때 동기적으로 최신 항공편 정보들을 이더리움 백엔드에 요청하는 구조임
  - 그때 Oracle에 대하여 이벤트가 발생되며, 오라클은 이 이벤트에 대응하여 데이터를 반환해주는 것
  - `.processFlightStatus`가 받아서 처리해줄 것

## 두 `.solidity` 파일을 다루며 신경써야 할 것

- 어떤 것이 persistent data로서 `Data.sol`에 들어가야 하고, 어떤 것이 어플리케이션 로직으로서 `App.sol`에 들어가야 하는지
- 의존성을 잘 살피자
  - `Data.sol`가 배포되고 난 뒤에 `App.sol`가 패포되어야 한다. 그래야 `App.sol`에서 `Data.sol`을 참조하여 데이터를 활용할 수 있게 될 테니까.
  - `App.sol`의 `constructor`에서 `Data.sol`의 주소를 필요로 한다

## Test - `test/flightSurety.js`

- 대부분 Multiparty 기능을 테스트하기 위한 파일
- 현재 프로젝트 구조가 얽히고 설킨 것이 많기 때문에, 처음에는 제대로 작동 안 함

## Test - `test/oracles.js`

- 다수의 오라클을 생성해내서 제대로 로드 밸런싱이 작동하는지 테스트하기 위한 파일

## Migration - `migrations/2_deploy_contracts.js`

- 테스트를 할 때면 항상 새로운 컨트랙트가 생성되는 셈이므로, 테스트하기가 매우 번거롭다
  - `App.sol`이 항상 새로운 주소를 보도록 고쳐주어야 하므로
- 그래서 아예 `Data.sol`의 백엔드 환경이 고정적으로 배포되도록 설정해줄 수도 있다.

### 19,20번째 라인의 의미

- 필수 파일은 아니지만, 일을 쉽게 해준다
- 컨트랙트 파일을 블록체인에 배포할 때마다, 클라이언트 DApp과 서버 DApp이 컨트랙트가 참조할 수 있는 *현재 배포된 컨트랙트의 주소* 를 별도의 `json`파일에 기록해준다
  - 각각 `dapp/` 및 `server/` 디렉토리에 생성된다
  - `config.json`에는 현재 배포된 컨트랙트에 대한 정보다 담겨있다.
  - 이후 클라리언트/서버 DApp에서는 해당 `json`을 동적으로 불러오기만 하면 된다

## Client DApp

- 아주 기본적인 HTML으로 구성 (`index.html`)
- `index.js`에 webpack을 통한 Hot-reload가 적용되어있음
- `dom.js`는 DOM 조작을 추상화해주는 클래스
  - 직접 고칠 일은 없음
- `contract.js`는 연결 및 컨트랙트 상호작용을 추상화해주는 클래스
  - 직접 고칠 일은 없음
  - Web3 버전이 1.0로, 0.2 버전과 아주 많이 다르므로 자료 검색시 유의
- **아주 중요!** Ganache 환경일 경우, Ganache를 재시작하게 되면 *기존에 생성했던 컨트랙트가 모두 사라져버리므로*, `config.json`에 적힌 컨트랙트 주소가 무효가 되버린다. 따라서 이 경우 `truffle migrate`를 또 한번 해야 할 것.

## Server DApp

- 아주 간단 (`server/index.js`)
- 템플릿으로 주어진 코드 상에는 별달리 API가 제공되지 않는다. `/api`는 별 기능을 하지 않고, 단지 요청을 받게만 되어있다. 왜 그럴까?
  - The primary purpose of the server is to simulate the Oracles and wait for events related to that.
  - 요청이 들어오는지 듣고 있다가, 어떤 요청이 들어오면 이를 블록체인 백엔드에 전달하고, 블록체인 백엔드가 오라클과 소통하고 그 결과는 블록체인 백엔드에 의하여 클라이언트로 전달되어야 한다. *이 서버를 통해서가 아니라*.
  - 관련 코드가 `/server/server.js`의 13번째 라인의 그것이다.
- 물론, 서버 라우팅을 통하여 부가 기능을 제공해줄 수는 있다.
  - 특정 시간대의 항공편을 쭈욱 열람할 수 있는 기능 등
  - 이건 선택 사항

---

## 전체적인 프로세스

우선 파일을 다 작성한다

1. `truffle compile`
2. `truffle migrate`
3. `truffle test`
